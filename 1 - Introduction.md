Lors du chapitre sur les graphes, nous avons vu que nous pouvons utiliser une technique dite de « retour arrière » comme stratégie pour explorer un espace problème à la recherche d’une solution. L’avantage de la dite approche, en outre, est qu’on peut évaluer une solution partielle et s’assurer qu’avant d’aller de l’avant vers une solution globale, cette solution partielle soit prometteuse. Si on peut évaluer que la solution partielle ne conviendra pas, on peut alors reculer d’un peu et tenter d’autres combinaisons de donner qui elles convergent de plus en plus près d’une solution. On évite ainsi une grande partie de la combinatoire des jeux de données à tester.

L’exemple que nous avons exploré ensemble concernait un jeu d’échec 8 cases par 8 cases pour lequel on désirait placer 8 reines sur le plateau sans qu’aucune reine ne « menace » l’autre, c’est-à-dire de telle sorte qu’il n’y ait qu’une seule reine par ligne, colonne et diagonale. Nous avions démontré comment on pouvait passer d’une solution de type force brute à plusieurs milliards de possibilités à tester jusqu’à une solution de retour arrière. Vous avez aussi dans les notes de cours un algorithme et un exemple graphique avec un plateau 4 cases par 4 cases et 4 reines.

Dans le cadre de ce travail, vous êtes appelés à implémenter dans un langage .NET de votre choix (C++, C#, VB.NET, F#) cet algorithme de retour arrière selon les modalités qui seront décrites dans les sections à suivre.
